## 一、头文件 + 命名空间

``` c++
#include <iostream>
#include <cstring> // 有大用的神秘头文件

using namespace std;
```

## 二、分析……

[**原题传送门**](https://www.luogu.com.cn/problem/P2802)

提示中明确表示了`1 <= n, m <= 9`

那么就有

``` c++
const short MAX_N = 9;
const short MAX_M = 9;
const short MAX_HEALTH = 6;
```

一个二维数组轻松管理**搜索方向**

``` c++
const short DIR[4][2] = {
    {1, 0},
    {-1, 0},
    {0, 1},
    {0, -1}
};
```

既然要求最短路径找到家，那么**广搜**更为合适

这样的话就需要一个**二维数组**来存**地图**

``` c++
short n, m;
short map[MAX_N + 2][MAX_M + 2];
```

还需要另一个用来存每个坐标点的**访问状态**和经过时**最大生命值**

``` c++
struct state {
    bool vis;
    short health;
} emp[MAX_N + 2][MAX_M + 2];
```

（使用`MAX_x + 2`是为了给地图上一圈保护边，防止**溢出**）

每一次访问的都要入队，以便下一次的进一步搜索

``` c++
int f = 0;
```

``` c++
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
        if (map[i][j] == 2) {
            q[f].x = i; // Set the start point
            q[f].y = j;
            q[f].step = 0; // Set the start step
            q[f].health = MAX_HEALTH; // Set the start health
            emp[i][j].vis = true; // Set the start point as visited
            emp[i][j].health = q[f].health;
        }
    }
}
```

## 队列处理

准备工作终于结束，接下来是

``` c++ 
struct pos {
    short x, y, health;
    int step;
} q[MAX_N * MAX_M * 100];

int f = 0, e = 0;
int shortest_step = -1;

int main() {
    cin >> n >> m;
    memset(map, 0, sizeof(map));
    for (int i = 0; i <= MAX_N + 1; i++) {
        for (int j = 0; j <= MAX_M + 1; j++) {
            emp[i][j].vis = false;
            emp[i][j].health = 0;
        }
    }

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            cin >> map[i][j];
        }
    }

    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= m; j++) {
            if (map[i][j] == 2) {
                q[f].x = i; // Set the start point
                q[f].y = j;
                q[f].step = 0; // Set the start step
                q[f].health = MAX_HEALTH; // Set the start health
                emp[i][j].vis = true; // Set the start point as visited
                emp[i][j].health = q[f].health;
            }
        }
    }
    for (; f <= e;) {
        short x = q[f].x, y = q[f].y, health = q[f].health;
        int step = q[f].step;
        f++;
        for (int k = 0; k < 4; k++) {
            short _x = x + DIR[k][0];
            short _y = y + DIR[k][1];
            short _health = (map[_x][_y] == 4 && health - 1 != 0) ? MAX_HEALTH : health - 1;
            int _step = step + 1;
            if (map[_x][_y] == 0) continue;
            if (emp[_x][_y].vis == true && emp[_x][_y].health > _health) continue;
            if (_health <= 0) continue;
            if (map[_x][_y] == 3 && (_step < shortest_step || shortest_step == -1)) {
                shortest_step = _step;
                continue;
            }
            e++;
            q[e].x = _x;
            q[e].y = _y;
            q[e].step = _step;
            q[e].health = _health;
            emp[_x][_y].vis = true;
            emp[_x][_y].health = _health;
        }
    }
    cout << shortest_step << endl;
}
```